/**
 * This file is generated by the SwaggerTSGenerator.
 * Do not edit.
*/
/* tslint:disable */

import { ValidatorFn } from '@angular/forms';
import { FormControl, FormGroup, FormArray } from '@angular/forms';

export abstract class BaseModel {
 
    constructor() {
        // define non enumerable properties so these are omitted in JSON.stringify.
        Object.defineProperty(this, "$formGroup", {
            get: this.getFormGroup,
            enumerable: false,
        });
        Object.defineProperty(this, "_formGroup", {
            enumerable: false,
            writable: true,
        });
    }

    /**
     * set the values.
     * @param values Can be used to set a webapi response to this newly constructed model
    */
    abstract setValues(values: any): void;

    /**
     * set the FormGroup values to the model values.
    */
    abstract setFormGroupValues();

    /** 
     * use $formGroup in angular's formBuilder to make a model driven (reactive) form. 
     *   this.form = this.formBuilder.group({
     *       pet: this.pet.$formGroup,
     *   }); 
    */
    $formGroup: FormGroup;

    protected _formGroup: FormGroup;
    protected abstract getFormGroup(): FormGroup;

    /** 
     * add one or more additional validators to the control
     * @param key Name of the control (is the same as the name of the attached model property) 
     * @param validators Validator(s) to add to the control 
    */
    addValidatorToControl(key: string, validators: ValidatorFn | ValidatorFn[]) {
        let control = this.$formGroup.controls[key];
        let vals: any = validators instanceof Array ? validators : [validators];
        if (control.validator) {
            vals.push(control.validator);
        }
        control.setValidators(vals);
    }

    protected fillModelArray<T>(object: BaseModel, key: string, values: Array<T>, subTypeFactoryFn: Function, type = undefined): void {
        if (values) {
            object[key] = new Array<T>();
            for(let value of values) {
                if (type) {
                    if (this.isSubType(value)) {
                        const subTypeInstance = subTypeFactoryFn(value);
                        object[key].push(subTypeInstance);
                    } else {
                        object[key].push(new type(value));
                    }
                } else {
                    object[key].push(value);
                }
            }
            // generate FormArray control elements
            this.fillFormArray<T>(key, object[key], type);
        }
    }
    protected isSubType(value: any): boolean {
        return value.hasOwnProperty('{{subTypePropertyName}}');
    }
    protected fillFormArray<T>(key: string, modelValues: any, type = undefined): void {
        if (this._formGroup) {
            let formArray = BaseModel.clearFormArray(this._formGroup, key);
            for (let modelValue of modelValues) {
                if (type) {
                    formArray.push((<BaseModel>modelValue).$formGroup);
                } else {
                    formArray.push(new FormControl(modelValue));
                }
            }
        }
    }
    private static clearFormArray(formGroup: FormGroup, key: string): FormArray {
        if (formGroup) {
            let formArray = <FormArray>formGroup.controls[key];
            for (let i = formArray.length-1; i >= 0; i--) {
                formArray.removeAt(i);                    
            }
            return formArray;
        }
    }
}